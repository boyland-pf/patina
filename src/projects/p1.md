## Project 1: OCaml


### Problem 1 \[★\]
> Goal of this exercise: Practice tuples, options, and recursion over lists.

An association list is a `('k * 'v) list` that can be used as a lookup table, mapping keys of type `'k` to values of type `'v`. To insert a key-value pair into an association list, we simply insert the pair to the beginning of the list:
```ocaml
let insert (k: 'k) (v: 'v) (al: ('k * 'v) list) : ('k * 'v) list =
  (k,v) :: al
```

The complementary `lookup` function looks like
```ocaml
let rec lookup (k: 'k) (al: ('k * 'v) list) : 'v option =
  (* your code here *)
```
To query the value associated with a key `k` in the list, we find the earliest pair whose first element matches `k`, and we return the associated value. However, `k` might not be in our list. That's why the return type is `'v option`, instead of `'v`.

For example,
```ocaml
let al = insert "x" 3 (insert "y" 2 (insert "x" 1 []))
(* al is now [("x", 3), ("y", 2), ("x", 1)] *)

let _ = assert (lookup "y" al = Some 2)
let _ = assert (lookup "x" al = Some 3)
let _ = assert (lookup "z" al = None)
```

Provide a recursive implementation for `lookup`.

---

### Problem 2 \[★★\]

> Goal of this exercise: Practice pattern matching and functions as first-class objects.

Patina\\(^{arith}\\) is a subset of Patina that only contains integer constants and binary expressions. Expressions will be represented in OCaml as abstract syntax trees as follows:
```ocaml
type binop = Add | Sub | Mul | Div
type expr = Const of int
          | Binary of binop * expr * expr
```

Here are two Patina\\(^{arith}\\) expressions represented as `expr`:
```ocaml
(* e1 represents the concrete expression "1 + 2 * 3" *)
let e1 =
  Binary (
    Add,
    Const 1,
    Binary (Mul, Const 2, Const 3))

(* e2 represents the concrete expression "3 * 4 - 30 / 6" *)
let e2 =
  Binary (
    Sub, 
    Binary (Mul, Const 3, Const 4),
    Binary (Div, Const 30, Const 6))
```

Below is a partially written interpreter for Patina\\(^{arith}\\). The main interpreter function is `interpret`, which evaluates a Patina\\(^{arith}\\) expression to an OCaml integer.

```ocaml
let interpret_op (op: binop) : int -> int -> int =
  match op with
  (* your code here *)

let rec interpret (e: expr) : int =
  match e with
  | Const n -> n
  | Binary (op, e1, e2) -> 
    (interpret_op op) (interpret e1) (interpret e2)

let _ = assert (interpret e1 = 7)
let _ = assert (interpret e2 = 7)
```

Note that `interpret` calls a helper function, `interpret_op`, which evaluates binary integer operators (`binop`) to their corresponding OCaml functions (`int -> int -> int`).

Complete the definition for `interpret_op`.

_Hint_: you can use [anonymous functions](https://cs3110.github.io/textbook/chapters/basics/functions.html?highlight=anonymous#anonymous-functions).

---

### Problem 3 \[★★★★\]

> Goal of this exercise: Practice pattern matching simulating "state changes" in a functional way.

Now let us extend Patina\\(^{arith}\\) into Patina\\(^{let}\\), which additionally supports variable bindings and sequences:
```ocaml
type binop = Add | Sub | Mul | Div
type expr = Const of int
          | Binary of binop * expr * expr
          | Id of string             (* new *)
          | Let of string * expr     (* new *)
          | Seq of expr list         (* new *)
```

A `Let` expression is a `string * expr` pair, where the value of the `expr` will be bound to the `string` name. The name will available in subsequent expressions in the parent `Seq` expression. 

Extend your interpreter in Problem 2 to support the new language constructs. Your `interpret` will have the following type:
```ocaml
type result = int option
let interpret (e: expr) : result = 
  (* your code here *)
```

The return type of `interpret` is now `int option` instead of `int`, because a `Let` expression doesn't produce any value. A `Seq` expression returns the value of the last expression in the sequence. An `Id` expression returns the value associated with the identifier string, or `None` if the identifier is unbound.

For example,
```ocaml
(* `e1` represents the concrete expression "let x: int = 2; x * 3" *)
let e1 = 
  Seq [
    Let ("x", Const 2);
    Binary (Mul, Id "x", Const 3)
  ]

let _ = assert (interpret e1 = Some 6)

(* `e2` represents the concrete expression
  let x : int = 1;
  { let x : int = 2; x };
  x *)
let e2 =
  Seq [
    Let ("x", Const (-1));
    Seq [
      Let ("x", Const 2);
      Id "x"
    ];
    Id "x"
  ]

let _ = assert (interpret e2 = Some (-1))
```

Provide an implementation for `interpret`. Your `interpret` may or may not be recursive, as long as it has the right type. You may assume that the test cases won't contain semantic or runtime errors, such as reference to an unbound variable, or empty sequences.

_Hints:_ 
1. You may want to use some kind of environment (e.g., what you did in Problem 1) to keep track of the values of variables that are in scope:
    ```ocaml
    type environment = (string * int) list
    ```

2. `interpret` can be non-recursive, and calls another helper function that actually evaluates the expressions recursively. The helper function may look like:
    ```ocaml
    let rec interpret' (e: expr) (env: environment) : (environment, result) =
      match e with
      (* ... *)
    ```
    Compared to `interpret`, the function `interpret'` additionally takes in an `environment`, and additionally returns an `environment` augmented by `Let` expressions [^1].

3. Be very careful how `Seq` and your environment interact.
---

### _(Bonus)_ Problem 4 \[★★★\]
Extend your interpreter to support Patina\\(^{ref}\\), which additionally contains assignments and while loops:
```ocaml
type binop = Add | Sub | Mul | Div
type loc = string
type expr = Const of int
          | Binary of binop * expr * expr
          | Id of string
          | Let of string * expr
          | Seq of expr list
          | Assign of loc * expr    (* new *)
          | While of expr * expr    (* new *)
```


_Hint_: You may want to use [`ref` cells](https://cs3110.github.io/textbook/chapters/mut/refs.html) for your environment:
  ```ocaml
  type environment = (string * int ref) list
  ```

---

<!-- 
You will gain some familiarity with the full Patina language by writing some short programs and playing with them using a prototype interpreter. -->


[^1]: This helper function is an example of what's called a [state monad](https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State), which is a functional way of simulating "state changes" without using mutable variables.
Also, if your `interpret'` function contains a lot of nested pattern matching on `option` values, it is very likely that your code can be greatly simplified by using a different kind of monad called the [maybe monad](https://cs3110.github.io/textbook/chapters/ds/monads.html?highlight=monad#the-maybe-monad).